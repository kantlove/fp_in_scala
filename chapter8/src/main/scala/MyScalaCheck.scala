package chapter8.my_scala_check

import chapter8.my_scala_check.Prop._

import scala.collection.mutable
import scala.util.Random

object Main extends TestSuite("Test suite 1") {
  property("string length") = forAll(Gen.string())(_.length > 3)

  property("even int") = forAll(Gen.int(0, 1000))(_ % 2 == 0)

  property("even int list") = forAll(Gen.listOf(Gen.int(0, 1000)))(_.forall(_ % 2 == 0))
}

/**
  * A container of all test cases.
  * @param name name of this test suite.
  */
class TestSuite(val name: String) {
  private val tests = mutable.Queue[Test]()

  private sealed case class Test(name: String, prop: Prop, testCount: Int)

  /**
    * Represents a declaration of a property.
    */
  sealed class PropertySpec(testCount: Int) {
    /**
      * Overrides the assignment operator `=`.
      * @param propertyName name of this property.
      * @param prop the property definition.
      */
    def update(propertyName: String, prop: Prop): Unit =
      tests += Test(propertyName, prop, testCount)
  }

  /**
    * Holds a property declaration.
    *
    * Example usage:
    * {{{
    *   property("empty string") = forAll(Gen.string())(_.isEmpty)
    * }}}
    * @return
    */
  def property = new PropertySpec(100)

  /**
    * Supplies a main method so that users don't have to write one inside
    * the test suite.
    */
  def main(args: Array[String]): Unit = {
    tests map { test =>
      println(s"\n- Test: ${test.name}")
      test.prop.check(test.testCount) match {
        case Passed =>
          println("Success")
          Passed
        case f @ Failed(reason, succeeded) =>
          println(s"Failed after succeeded $succeeded tests\n$reason")
          f
      }
    } find {
      case _: Failed => true
    } foreach { _ =>
      System.exit(-1) // signal error to the caller
    }
  }

  /**
    * Defines a property that tests `predicate` on test cases generated by `g`.
    * @param g test case generator.
    * @param predicate a predicate function to test against the test cases.
    */
  def forAll[A](g: Gen[A])(predicate: A => Boolean): Prop = {
    Prop(testCount => {
      val data = Stream.fill(testCount)(g.next).zipWithIndex

      val tested = data map {
        case (a, i) =>
          try {
            if(predicate(a)) Passed
            else Failed(createFailureMessage(a), i)
          }
          catch {
            case e: Exception => Failed(createFailureMessage(a, e), i)
          }
      }

      val firstFailure = tested.find {
        case _: Failed => true
        case _ => false
      }

      firstFailure getOrElse Passed
    })
  }

  private def createFailureMessage[A](a: A): String = s"Falsified by: $a"

  private def createFailureMessage[A](a: A, e: Exception): String = {
    s"${createFailureMessage(a)}\n" +
      s"Exception: $e"
  }
}

/**
  * Represents a test result.
  */
trait Result
case object Passed extends Result
case class Failed(reason: String, succeeded: Int) extends Result

object Prop {
  // Sometimes alias helps increase code readability
  type TestCount = Int
}

/**
  * Represents a property.
  * @param check a function containing the test logic.
  */
case class Prop(check: TestCount => Result) {
  /**
    * Logical AND operator.
    */
  def &&(p: Prop): Prop =
    Prop(testCount => {
      check(testCount) match {
        case Passed => p.check(testCount)
        case f: Failed => f
      }
    })

  /**
    * Logical OR operator.
    */
  def ||(p: Prop): Prop =
    Prop(testCount => {
      check(testCount) match {
        case Passed => Passed
        case _: Failed => p.check(testCount)
      }
    })
}

object Sampler {
  val int: Sampler[Int] = new Sampler[Int] {
    override def next: Int = Random.nextInt()
  }

  val boolean: Sampler[Boolean] = new Sampler[Boolean] {
    override def next: Boolean = Random.nextBoolean()
  }

  val char: Sampler[Char] = new Sampler[Char] {
    override def next: Char = Random.nextPrintableChar()
  }

  def string(maxLength: Int): Sampler[String] = new Sampler[String] {
    override def next: String = {
      val length = int.map(math.abs(_) % maxLength).next
      List.fill(length)(char.next).mkString("")
    }
  }
}

/**
  * Represents a sampler that knows how to create sample data.
  * @tparam A type of the data.
  */
trait Sampler[A] {
  /**
    * Returns new data.
    */
  def next: A

  def map[B](f: A => B): Sampler[B] = {
    val self = this
    new Sampler[B] {
      override def next: B = f(self.next)
    }
  }
}

object Gen {
  def unit[A](a: => A): Gen[A] =
    new Gen[A](new Sampler[A] {
      override def next: A = a
    })

  // to: exclusive
  def int(from: Int, to: Int): Gen[Int] =
    new Gen[Int](Sampler.int.map(_ % (to - from) + from))

  def int2(from: Int, to: Int): Gen[(Int, Int)] = {
    val x = int(from, to)
    val y = int(from, to)
    x.flatMap(xi => y.map(yi => (xi, yi)))
  }

  def boolean: Gen[Boolean] = new Gen[Boolean](Sampler.boolean)

  def char: Gen[Char] = new Gen[Char](Sampler.char)

  def string(maxLength: Int = 50): Gen[String] = new Gen[String](Sampler.string(maxLength))

  def listOf[A](g: Gen[A]): Gen[List[A]] =
    int(0, 50).map(List.fill(_)(g.sampler.next))

  def listOfN[A](n: Int, g: Gen[A]): Gen[List[A]] =
    new Gen[List[A]](new Sampler[List[A]] {
      override def next: List[A] = List.fill(n)(g.sampler.next)
    })
}

/**
  * Represents a test case generator.
  * @param sampler
  * @tparam A type of the data.
  */
case class Gen[A](private val sampler: Sampler[A]) extends Sampler[A] {
  override def map[B](f: A => B): Gen[B] = Gen(sampler.map(f))

  def flatMap[B](f: A => Gen[B]): Gen[B] = map(f).sampler.next

  def toOption: Gen[Option[A]] = map(Option(_))

  override def next: A = sampler.next

  def unsized: SGen[A] = ???
}

object SGen {
  def listOf[A](g: Gen[A]): SGen[List[A]] = SGen(Gen.listOfN(_, g))
}

case class SGen[A](forSize: Int => Gen[A])